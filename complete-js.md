# Structure

2. Fundamentals 1
3. Fundamentals 2
4. Developer Skills
5. DOM manipulation
6. How JS works nehind the scenes
7. Modern JS, operators, keywords
8. Functions
9. Modern Operators (ES6+)
10. Functions
11. Arrays
12. Numbers, Dates, Timers
13. Advanced DOM
14. OOP in JS
15. Mapty project
16. Asynchronous JS
17. Modern JS applications
18. Forkify project
19. Deployment and GIT

- Projects are built for each section

# What's JS?

- Javascript is a high level, object-oriented, multi-paradigm programming language
- PL = a way of instructing computers to do things
- High level = we don't have to worry about complex stuff like memory management, writing data types
- Object-oriented = almost everthing is an object
- Multiparadign = we can use dfft styles of programming
- Adds interactivity to web pages and web apps, manipulating the DOM, loading data form remote servers
- "There's nothing you can't do with Javascript - well almost"
- Frontend -> JS, ReactJs, AngularJs, VueJs
- Webapps & Serverside apps -> NodeJs, Bun, Deno
- Natiive mobile apps -> ReactNative, Ionic, Apache Codova
- Native desktop apps -> ElectronJs, Tauri

**There is a yearly release of Javascript. ES6/ES2015 onwards known as modern javascriipt**

## DataTypes

- A Value can either be an `object` or a `primitive`

Primitve data types

1. Number: floating point numbers. Used for decimals and integers
2. String: sequence of xters. Used for text
3. Boolean: Logical tyoe, can only be ` true`` or  `false`
4. Undefined: vallue taken by a variable that not yet defined
5. Null: also means `empty value`
6. Symbol (ES2015): Value that is unique and cannot be changed
7. BigInt (ES2020): Larger integers than the `Number` typpe can hold

JS is dynamically typed. Data Types are automatically determned. We can manipulate variables using values of dfft typess

## Declaring variibles

`let` & `const` from ES6
`var` from before ES5

`let` = declare a variable that is expected to me mutated

`const` = declare an immutable variable.
Note: You can declare an emoty value with `const`. Always provide a value

> It's a good practice to use `const` at first until you need to mutate t. Then change it to `let`
> Mutatign varables is a source of many hard-to-find bugs

`var`:

## Operators

Let us do things with values and variables
Examples:

```js
x - 1; //-,+,*,/
x++; //Increment operators
x--; //Decrement operators

x -= 2; //decrement and reassign
x += 2; //increment and reassign

//comparison operators
age > limit; //>, <, >=, <=
```

### Take note of operator precendence

-google search `mdn operator precendence`
MDN = a JS online documentaion

## Note:

1. Strings and literals
2. Taking decisions with `if...else if...esle`
3. Type conversion & coarsion

- Conversion: manually convert the type to another
- Coarsion: Js automatically and implicitely converts btn types where necessary

4. Truthy and falsy values
5. Logic operators \(&&, ||, !\)
6. Statements & expressions
7. Conditional/Ternary operator: `?`...`:`

8. Activate strict mode
   Use `"strict"` at the start of teh script or the block of code
9. Functions
10. Arrow functions
11. Arrays

- Methods

```js
let a = [];
a.push("jay"); //add at the end, return new length
a.unshift("jay"); //add at the start
a.pop(); //remove last, return the removed el
a.shift(); //remove first
a.indexOf("jay"); //return index at which the el is located, -1 if not found

a.includes("jay"); // >:boolean
```

12. Objects

- Store key value pairs
- `dot` and `bracket` notation can be used to retrieve data or reassign values
- Methods: functions stored as values on the object

13. Loops & Iteration

- Using the `for` loop or using array methods and object methods /(`Array.forEach()`/)
- Note: `break`ing and `continue`ing in the loops
- `continue`: break out the current iteration and proceed with the loop
- `break`: break out the whole loop at the moment. E.g.

```js
for (let i;  < a.length; i++){
    if (typeof a[i] !== 'string') continue //only proceed with below code for strings
}

for (let i;  < a.length; i++){
    if (typeof a[i] === 'number') break // stop iterating once we find a number
}
```

# JS in the browser

## Guess my number

1. DOM manipulation
   = technical term for Js interacting with the web page

DOM(Document Object Model) = structured representation of HTML documents. Allows Js to access the HTML elements and styles, to manipulate them.

When the page loads, a tree structure s generated by the browser

2. DOM Tree structure

- Looks like a famly tree.
- There are child, parent, grandparent & siblng nodes, that Js can interact with
- The `document` is the first level node. It is also represented with a special object that serves as entry point to the DOM
- The first child of the `document` node is the `html` element, which s the root element
- The html element has two children: `head` and `body` elements
- It goes far deeper
- The DOM tree has nodes for text, comments, etc

> The DOM is not part of Js, it is an API implemented by the browsers in Javascript. It is one of many web APIs.
> THere's a particular DOM specification that browsers implement.
> Other web APIS: timers, fetch, location, navigation, etc

3. Selecting and manipulating elements

```js
document.querySelector('<selector>').textContent
document.querySelector('.className').textContent
document.querySelector('#id').textContent
document.querySelector('tag['attribute']').value
document.querySelectorAll('btn') //returns nodelist: an active list of matched elements
```

4. Handling click events

```js
selectedElVar.addEventListener("typeofevent", handlerFunction);
selectedElVar.addEventListener("click", (e) => {});
document.querySelector(".class").addEventListener("click", (e) => {});
```

5. Random number

```js
const num = Math.trunc(Math.random() * 20) + 1;
```

> Refactor repetitive code into `function`s
> The DRY: Donot Repeat Yourself

6. Manipulating CSS styles

```js
document.querySelector("body").style.backgroundColor = "#60b347";
//specifiy a string, two-word properties adopt a camelCase notation
document.querySelector("body").style.width;
//these are inline styles, not CSS being manipulated
```

## Modal

7. Working with classes
   When we want to manipulate many styles at the same time

```js
const modal;
modal.classList.remove('hidden')
//.contains, .add, .toggle
```

8. Key press events

```js
el.addEventListener("keypress | keydown | keyup", function (e) {
  console.log(e.key);
});
```

## Pig game

- Mainly practicing and reinforcing what has already been taught in the section

> Sometimes you need to write `init` and `reset` functions to initailize the app data and reset it respectively
> The images are changed by manipulating the `src` attribute

```js
diceEl.src = `dice-${dice}.png`;
```

> You may have to declare a global or higher scope varibale to store soem data which is:
>
> > - Used by many dfft functions
> > - The value is returned/manipulated by one function yet used by another function.
> > - The value is needed even after the function has finished executing

# JS behind the scenes

1. ## High Level overview of JS

- Js is a _Highlevel_, _Prototype-based object oriented_, _Multiparadigm_, _Interpreted or Just-in-time compiled_, _Dynamic_, _Single-threaded_, _Garbage-collected_ programming language with _First class functions_ and _Non-blocking event loop_ _Concurrency model_

1. Highlevel:

   - any program needs resources like memory,
   - low level langs like C/C++ require the developer to manage to the resources manually
   - High level PLs like JS, Python, developers need not worry about things like memory, hardware connectivity, etc. Thanks to the layer of abstruction provided by the compiler/garbage collector automatically

2. Garbage collector

   - An algorithminside the Js engine whih automatically removes old unusedobjects from the memory, to avoid clogging it up with unneccessary stuff

3. JIT compiled

   - Converted to machine code

4. Multiparadigm

   - Paradigm = an approach and overall mindset of structuring code, which will direct your coding style and technque
   - 3 popular ones: procedural, functional, OOP
   - Classified as imperative or declarative
   - Many languages lie to one side of paradigms, but JS applies all them making it flexible and versatile

5. Prototype-based object-oriented
   - Everything, except primitve types(Numbers, strings, etc) is an object
   - Arrays are objects. We can create arrays and then automatically used a bunch of methods and properties that are automatcally added to the array.
   - This is possible b'se arrays are made from a blueprint(aka PROTOTYPE object) from which all arrays inherit methods and properties
   ```js
   Array.prototype.push;
   Array.prototype.indexOf;
   Array.prototype.length;
   ```
6. First class functions

   - means functions are simple treated as variables. We can pass them into other Fx and return them from other Fx.
   - eg. callbacks, eventhandlers

7. Dynamic

   - No data type definitions assgned to variable declarations. Types become known at runtime
   - Data types of variables are automatically changed

8. Single-threaded

   - Concurrency model = a fancy term meaning how the Js engine handles multiple tasks happenning at the same time
   - Js runs in on single thread. Can only do one task at a time.

   - The event loop prevents blocking of the thread by taking long running tasks and executing them in he background. It puts them back in the main thread once they are finished

9. Non blocking event loop

10. #### The JS engine and runtime
    - A JS engine is a program that executes Js code. I.e converts it to binary code that the machine can tun.
    - Eg. Google's V8 engine used in Chrome, Node, Electron
    - Every browser has it own engine

##### Components of the engine

1. Call stack

- Where the code is actually executed, following the executiion context

2. Heap

- Stores all objects that the app needs

##### How is the code executed

- Compilation: Entire code is converted into machine code at once, and written to a binary file that can be executed byt the any computer

- Interpretation: nterpreter runs through the source code and executes it line by lines. This makes many langs slowers to execute.

- Js is nolonger simly interpreted. It uses JIt compilation.
- This means that the entire code is converted into machine code at once, then execued immediately. No need to store the code into a bin file.

###### Steps in JIT compilation

1.  Parsing

- Reading the code. The code is parsed into a data structure called Abstract Syntax Tree (AST)
- This step checks for syntax errors.
- It will stored variable, function, etc, declarations

2.  Compilation

    - The AST is converted to machine code which follows to the next step

3.  Execution
4.  Optimization

    - During execution.

    - All these steps occur in special threads thta we can not access in the code.

###### The JS runtime

- Imagine a container including all the things that we need to use Javascript(e.g. in this case the browser)
- Contains the JS engine to execute the Js code
- Contains APIs (The browser contains web APIs)
- These are not part of the Js langauge itself. Js simply gets access to these APIs via the global `window` object for the case of browsers
- Contains a `call back queue` : this is a special data stricture that holds all the call back fnctions that are waiting to be pushed on it the call stack

4. #### Execution contexts and the Call Stack

- After compilation, a global _execution context_ is created for top level code(code not inside a function)
- Functions are only executed when they are called
- _An execution context_: Is an environment in which a piece of Javascript is executed. Stores all the necessary information for the code to be executed.
- Exactly one execution context is created for code that is not inside any function (top level code)

- For each and every function call, A new execution context is created. Including methods.

- When all functions are executed, the engine waits for callback functions, running them in the callback queue

> Execution context in detail: What's inside?

1. Variable environment

- `let`, `const`, & `var` declarations
- Functions
- `arguments` object
  > - A function's declaratons create a variable environment

2. Scope chain
   - consists of references to variables outside the current/function's variable environment
     > - Functions can also access the parent's variable environment
3. `this` keyword

> NOte

    The EC of arrow functions donot get their `arguments` object and `this` keyword.
     They simply use those of their nearest parent functions

> The Call stack

    - A place where ECs get staked one on top of the others, to keep track of where we are in the execution.
    - The EC is removed once finished executing

5. #### Scope and the Scope chain

- Scoping: controls how he program's variables are organised and accessed. "where do variables live?" or "Where can we access a certain variable, and where not?"

- _Lexical scoping_: Scoping is controlled by placement of functions and blocks in the code

- _Scope_: Space or environment in which a certain variable is declared(variable envt in case of functions). There is gloabal scope, function scope, and block scope

- Scope of a variable: Region of our code where a certain variable an be accessed.

> 3 Types of scope

    Global scope: Outside any function/block. Vars declared in global scope are accessible everywhere.

    Function scope: Vars declared insde functions are only accessible inside the functon. AKA LOCAL scope.

    Block scope( code tat is in curly brackets): Vars are only accessible inside the block (*block scope*).
    NOTE: This only applies to let and const variables. Functions are also block scoped in strict mode.
    - If a variable is declared using var, it can be accessed outside the block

> Inner scopes have access to variables in all higher-level/outer scopes
> The scope can is a one way variable lookup process

6. #### Variable environment, hoisting and the TDZ

- _Hoisting_: Makes some types of variables accessible/usable in the code before they are actually declared. "Variables lifted to the top of their scope".
- Before execution, code is scanned for variable declaratons, and for each variable, a new property is created in the "variable environment object"

- `function` declarations are: hoisted, actual function of the value is stored, block scope. We can use functions before they are declared

- `var` variables: Hoisted, The initial value is `undefined`(You get an error usig the var before it's declared), function scoped

- `let` and `const` variables: not hoisted, they are hoisted but their value is set. These variables are placed in the TDZ (temporal dead zone).

- `function` expressions and arrows: Hoisting depends on whether they are declared by var, or let / const. Remember they are simply values

##### TDZ

- A region of a block code, where a variable can not be accessed. We get a ReferenceError: Cannot access 'varName' before initialization
- It makes it easy to avoid and catch errors. Accessing variables befor declaration is bad practice and should be avoided.
- Makes const variables actually work.
- Hoisting: Enables using functions b4 actual declaration.

7. #### The `this` keyword

- In the global scope, it references to the `Window` object
- Inside a regular function call, it is `undefined` in strict mode and `global/window` object in sloppy mode

- If it's an arrow function, the `this` keyword references to the `this` of it's parent

- If it's a method call, it references to the `object` calling the method. Even if the method is just borrowed from another object

```js
const matilda = {
  year: 2001,
  calcage: function () {
    console.log(2037 - this.year);
  },
};
matilda.calcAge(); //- 36

const jon = {
  year: 2017,
};

jon.calcAge = matilda.calcAge;
jon.calcAge(); //- 20
```

8. #### Regular and Arrow functions

- Arrow functions donot get thier own `this` keyword. They use that of the surrounding scope

- An object declaration doesnot create its own block. So the `this` keyword in an arrow function refers to the scope outside the object

- It is not a code block, the \{\} brackets simply mean an object literal

```js
const matilda = {
    name: 'Matilda'
  year: 2001,
  calcage: function () {
    console.log(2037 - this.year);
  },
  greet: () => console(this.name),
  sayHi: function(){
    console.log(this.name)
  }
};

matilda.greet(); //- undefined
matilda.sayHi() //- 'Matilda'
```

> A regualr function has the `this` keyword set to undefined
> Here's a trick

```js
const jonas = {
  year: 1991,
  isMel: function () {
    console.log(this); //- undefined inside a regular function
    self.year; //- 1991
  },
};

// soluton2 is to simply use an arrow function
const jonas = {
  year: 1991,
  isMel: function () {
    console.log(this); //- undefined inside a regular function
    self.year; //- 1991
  },
  isMel2: () => {
    console.log(this); //- the matilda object
    console.log(this.year); //- 1991
  },
};
```

> The `arguments` object has properties referencing the arguments passed into the function.

9. #### Primitives and Objects

- Primitives: Number, String, Boolean, Undefined, Null, Symbol, BigInt
- Reference types (Objects): Object literals, Arrays, Functions, etc

> All reference types (i.e objects) are stored in the memory HEAP
> Primitive types are stored in the call stack i.e in the ECs in which they are created

> The JS engine treats every variable like this

    - When we declare a varibale, it's identifier doesnot caryy the value with it.
    - The identifier is allocated to an address in the memory in which the data/value is actually stored
    - Setting a variable to another var: simply points the new identifier to the same address

```js
let age = 30;
let oldAge = age;
age = 32;

console.log(age); //- 31
console.log(oldAge); //- 30
```

     - When the var value is mutated, a new piece of memory is created, to store the new value, and that identifier is set to point to the new address

> For Objects/References, since they are stored in the HEAP

    - When a var is declared, a piece of memory in the heap is allocated to store the value.
    - The identifier is allocated to an address which holds not the data itself but the reference(i.e another address) to the actual data in the heap
    - It is done so to avoid over filling up the call stack. So the stack only stores references to the actual data.

> Other JS Behind the scenes that are kept for later
>
> 1. Prototypal Inheritance
> 2. Event loop
> 3. How the DOM works

# Data structures, Modern operators and strings: Modern JS

### A. Destructuring Arrays

- Declaring variables to contain the values of items in an array
- Destructuring assignment
- It is like unpacking

```js
const arr = [2, 3, 4];
const [x, y, z] = arr;

console.log(x, y, z); //- 2 3 4

//skpping elements
const [first, ,third] = arr
console.log(first, third) //- 2 4

// nested array
const nest = [1, 3, 5, [9, 15, 21]]
const [i, ,j, [k, ,m]]
console.log(i, j, k, m) //- 1 3 9 21

// setting default values
const [p=0, q=1, r, s=3] = [2, 3]
console.log(p,q,r,s) //- 0 1 undefined 3

```

### B. Destructuring objects

- We use curly braces. We provide the variable names that exactly match the object properties.
- No need to skip elements and order of elements does not matter.

```js
const restuarant = {
    name: 'restO',
    openingHours: [],
    categories: {}
}
const {name, openingHours}


// What if we want the var names to be different
// Specify the object property identifiers and use a full colon to name the var
const {name: restName, openningHours: hours, categories: tags} = restaurant
console.log(name, openningHours, categories)

// setting default values
// Use equals
// Can be combined with custom name destructuring. Name first defaul second
const {menu = [], startMenu: starters = []} = restaurant

// mutating variable
// wrap the code in ()
let a = 111
let b = 99
const obj = {a: 2, b: 7, c: 78}
({a,b} = obj) // mutates the variable

// nested objects
// specifiy the property name, and use nexted destructuring
const { fri: {open, close} } = openningHours

//a practical appliation of this is to provide an option obejct to functions,
// which is the destructured to get the required properties,
// without writing many lines of code
```

### C. The spread operator (...)

- We can use it unpack an array into individual items
- Avoids unneccesarily looping through an arr
- Used to copy arrays, and to merge arrays
- Used to loop over the items of iterables: strings, arrays, sets, maps, BUT NOT objects
- Passing multiple arguments into functions
- Spread properties of objects into individual values

```js
const arr = [2, 4, 9, 8, 4];
const newArr = [1, 2, ...arr];
const newArr2 = [...arr, 11, 13];

// copy arr

// merge arrays

// iterables
const str = "hrnmddr";
const letters = [...str, "", "s"];

// passing arguments into functions

// objects
```

### D. The `rest` pattern and `rest` parameters

- Still using the spread syntax
- Take the remaining elements into a variable
- We can the three dots on both sides of the assignment operator

```js
const [a, b, ...others] = [1, 2, 3, 4, 5, 6, 7, 8, 9];
console.log(others); //- [3,4,5,6,7,8,9]
```

- Works for objects too: the remaining elements are collcted into an object
- Can be used to collect any arbiturary number of arguments passed to a function into one arr

```js
const add = functon(...nums){
    let sum = 0;
    for (let i=0; i < nums.length; i++) sum += nums[i]
    return sum
}
```

### E. Short circuiting with `&&` and `||`

- Logical operators can use ANY data types
- They can return ANY data type
- They short circuit
- They work with any number of comparants, evaluation follows right to left

- ---OR---

```js
// Checks for any truthy value, shorts whenever it finds it
3 || "Jonas"; // first truthy value is return //- 3
" " || "Hiren"; // Hiren
```

- ---AND---
- Shorts when the first value is falsy and returns that operant
- When all of them are truthy, the evaluation continues and the last operand is returned
- Short circuits whenever it finds a falsy value
- Can be used to avoid some `if` statements
- can be used to set default values

### F. Nullish coalescing operator

----`??`----

- Works like the ---OR--- operator but works with nullish values like 0, null, ''
- Whenever a nullish value is found, the evaluation short circuits and returns that value

### G. `for...of` loop

- Looping over arrays

```js
const menu = [1, 2, 3, 4, 5, 6, 7, 8];
for (const item of menu) console.log(item);
```

- the `item` keyword represents the arr item at the current iteration
- We can still use the `break`, `continue`, keywords in this `for...of` loop
- It is a pan to get the current index

```js
for (item of menu.entries) {
  // each item is an array containing the index and the value
  console.log(`${item[0] + 1}: ${item[1]}`);
}

//using destructuring
for (const [i, el] of menu.entries) {
  console.log(`${i + 1}: ${el}`);
}
```

### H. Enhanced object literals

- ES6 enhanced object literals
- If a property being copied from another piece of code has the exact same, we can simply use that name without a full colon
- When writing methods, you can simply use the identifier, plus paranthesis, without the `function` keyword
- We can compute property names: Using the square brackets syntax

```js
const days = ["mon", "tue", "wed", "thu", "fri"];
const obj = {
  days,
  prop1: "data",
  doSomeThing(...params) {},
  [days[1]]: ["someVal", "andMore", "anything"],
  [`${days[2]}s`]: ["someVal", "andMore", "anything"],
};
```

### I. Optional Chaining

- Using the question mark key operator

```js
console.log(restaurant.openHours.mon.open); //- returns error if mon doesn't exist
console.log(restaurant.openHours?.mon?.open); // if a ceratin property doesn't exist, `undefined` is returned immedaitely
```

- Makes conditional chaning easy, esp there are many levels of objects
- We can check if a method exists, if we are trying to call it

```js
//e.g.
const days = ["mon", "tue", "wed", "thu", "fri"];

for (const day of days) {
  const open = restaurant.openingHours[day]?.open; //- using squarebracket syntax to access the object properties
}
```

### J. Looping over object

- Using Object.`keys`, .`values`, .`keys`

```js
// property NAMES
for (const day of Object.keys(openningHours)){
    //Object.keys() retruns an array
}

// property VALUES -> Object.values()
Object.values()

// both keys and values -> Object.entries()
Object.entries(objName)

// with destructuring
for (const [key, {open, close}] of Object.entries(openningHours))
```

### K. SETS

- A set is a collection of unique values. This can be useful in some cases
- syntax: Use `new Set()`
- Can hold different data types
- All dupliates are remove
- Similar to an array: they're are iterables, no key-value pairs
- The order doesnot matter
- Pass in any iterable data type: string, array

```js
const nameSet = new Set("Jonas"); //- Set(5) {'J', 'o', 'n', 'a', 's'}
const orderSet = new Set(["pasta", "pizza", "pizza", "risotto", "pasta"]); //- {"pasta", "pizza", "risotto"}

///working with sets
orderSet.size; //- 3 //how many dfft items are in the set

// check if it conatians something
orderSet.has("Bread"); //- false //similar to Array.includes()

//add, delete
orderSet.add("Garlic bread");
orderSet.delete("Garlic bread");
orderSet.clear(); //delete all

//retreiving: there's no way of getting values out of a set
// sets are iterables

for (const order of orderSet) console.log(order);

//Eg. removing duplicates from arrays
const staff = ["waiter", "chef", "waiter", "manager", "chef", "waiter"];
const staffUnique = [...new Set(staff)];
```

### L. MAPS

- data is stored in keyvalue pairs
- The keys can be an data type
- We use the Map() constructor

```js
const rest = new Map()
rest.set('name', 'Classico Italiano')
rest.set(1, 'Firenze, Italy'),

// the set() method returns the new Map, allowing chaining of them
rest.set('open', [1,4,8])
    .set(true, 'we are open'),
    .set(false, 'we are closed')

// reading Map data
rest.get('name') // pass in the name of the key: data type is important
rest.get(true)
rest.get(1)

rest.has() //contains?
rest.delete(2) //delete a pair
rest.clear() //remove all


```

> Deleting properties from objects can be done using the `delete` operator
> But this is a slow process and not encouraged. The `Map.delete()` method is faster

> Maps can allow us set keys as DOM elements

```js
// another way of populating a map: use array of arrays
const qn = new Map([
  ["qn", "What is the best programming language n the world?"],
  [1, "C"],
  [2, "Java"],
  [3, "Python"],
  [4, "Javascript"],
  ["correct", 4],
  [true, "You got it"],
  [false, "Try agan"],
]);

// convert btn objects and maps
const hoursMap = new Map(Object.entries(openningHours)); //Object.entries returns an array of arrays

//iteration
for (const [key, value] of qn) {
  if (typeof key === "number") console.log(`Answer ${key}: ${value}`);
}

// convert map to array
console.log([...qn]);
```

### M. Which data structure to use?

1. Sources of data

- 1. From the program itself: Data written directly in the source code( e.g. status message)
- 2. From the UI: Data input by user or written in the DOM
- 3. From external source: Data fetched from external webApi

2.  We get collections of data
3.  If we need a simple list of data, we use arrays or sets
4.  If we need key/value pairs, we use objects or maps
5.  If the fetched data is JSON, it is easily converted to and fro objects, so it is better to use objects

6.  There are other data structures, like weakMaps and weakSets
7.  Arrays Vs. Sets

    > Arrays

        - Use when you ned an oredred lst of values that might also contain duplicates
        - Use when you need to manipulate the data

    > Sets

        - Use when you need to work with unique values
        - Use when high performance is really important
        - Use to remove duplicates form arrays

8.  Objects Vs. Maps

    > Objects

        - More traditional key/value store
        - Easier t write and access values with the object literals and the dot and bracktes notation
        - Use when you need to include functions(methods)
        - Use when working with JSON

    > Maps

        - Better performance
        - Keys can have any data type
        - Easier to iterate
        - easier to compute the size
        - Use when you simply need to map eys to values
        - Use when you need need keys that are not strings

### N. Working with strings

```js
const airline = "Ebb Uganda Airline";

airline.length; //no of xters including space, special xters
airline.indexOf("i"); //1st occurence of 'r'
airline.lastIndexOf("i"); //We can also search for entire words. This is case sensitive

//extract part of the string
airline.slice(4); //start index to extract
airline.slice(4, 7); //start and end indices for extraction. Stops extracting before reaching index 7

// eg.
airline.slice(0, airline.indexOf(" ")); //extract the first word
airline.slice(0, airline.lastIndexOf(" ") + 1); //except the last word

//provde negative values to satrt from the last index
airline.slice();

//transformation
airline.toLowerCase();
airline.toUpperCase();

" hello.hj@jfnf.com \n".trim(); // remove whitespace

// replace parts of strings
"288,97₤".replace("₤", "$").replace(",", ".");

///using regExp
"All passemgers come to boarding door 23. Boarding door 23".replace(
  /door/g,
  "gate"
);

//booleans:
"A320neo".includes("A32"); //- true
"Airbus A320neo".startWith("Ai"); //- true
"A320neo".endsWith("neo"); //- true

//splitting, joining
"a+nice+string".split("+"); //-> array of split parts
const [firstName, sirName] = "Hiren Maddara"
  .split(" ")

  [("Mr.", firstName, sirName.toUpperCase())].join(" "); //- join using the specified seprator

//padding
"Go away".padStart(25, "G").padEnd(30, "y"); //-add the xter to the str to make the specified length

//repeating
"No".repeat(5); //- repeat the str the specified no of times
```

> Normlaize searching in the mdn documentation the dfft parts of Js, or the methods you want to learn about.
> There are many other strng methods. But take note of the most important ones.

# A closer look at functions

### 1. Default parameters

- One way is to rely on short circuiting to set default values

```js
function createBooking(flght, passengers, price) {
  passengers = passengers || 1;
  price = price || 199;

  bookings.push({ flight, passengers, price });
}
```

- A better way in ES6 is to set defaults in the function declaration

```js
function createBooking(flght, passengers = 1, price = 139 * passengers) {
  passengers = passengers || 1;
  price = price || 199;

  bookings.push({ flight, passengers, price });
}
```

- _The default values accept any expressions_
- We can hence do calculations based on the previous parameters. As shown above

> Note

    We cannot skip arguments when calling the functions. The arguments must be in their specified order.
    To invoke the default params, specify undefined in that place

```js
creakingBooking("LVH123");
creakingBooking("LVH123", 23, 800);
creakingBooking("LVH123", undefined, 800);
```

### 2. How passing arguments works: value vs. reference

### 3. First class & Higher order functions

1. First class functions means

   - Functions are simply values
   - functions are just another `typeof` objects

   - We can store functions in variiables or properties
   - we can pass functions as argumenat to other functions
   - Return functions from functions
   - Call methods on functions like `bind()`

2. Higher order functions

- a function that receives another functions as an argument, that returns a new function or both
- This is only possible b'se of first class functions

  - Function that receives another function
  - Function tat returns another function

> Note

    First class is just a concept that functions are treated as values. Not a big deal. And not in practice.
    - Using the concept to write higher order functions is the practical application

#### 4. Functions accepting callbacks

```js
const oneWord = function (str) {
  return str.replace(/ /g, "").toLowerCase();
};

const upperFirstWord = function (str) {
  const [first, ...others] = str.splt(" ");
  return [first.toUpperCase(), ...others].join(" ");
};

//higher order
const transformer = function (str, fn) {
  console.log("Original string: ", str);
  console.log(`Transformed string: ${fn(str)}`);
  console.log(`Transformed by: ${fn.name}`); //functions ahve properties too
  return fn(str);
};

//JS uses callbacks all the time
//- callbaks allow us to create abstraction
```

#### 5. Functions returning functions

```js
const greet = function (greeting) {
  return function (name) {
    console.log(`${greeting} ${name} \n`);
  };
};

greet("hey")("Maddara");
greet("Good morning")("Everyone");

//arrow function approach
const greetArrow = (greeting) => (name) =>
  console.log(`${greeting} ${name} \n`);
```

### 6. The `call` and `apply` methods

- How to manually set the `this` keyword
- `call`: run the function and set the this keyword as the first argument

```js
const eurowings = {
    iata = 'EW'
}

const lufthansa = {iata = 'LH'}

const book = function(code, name){
    console.log(`Flight ${this.iata}${code} bbokked by ${name}`)
}

//- call method
book('234', 'Hiren M') //- error
book.call(eurowings, 234, 'Hiren M') //- Flight EW234 booked by Hiren M
book.call(lufthansa, 234, 'Hiren M') //- Flight LH234 booked by Hiren M
book.call(eurowings, 234, 'Hiren M') //- Flight EW234 booked by Hiren M

//- apply method
//like the `call` method but instead takes in an array of methods
const flightData = [583, 'George Cooper']
book.apply(eurowings, flightData) //takes in an array
book.call(eurowings, ...flightData)
```

### 7. The `bind` method

- also allows us to manually set the `this` keyword
- does not imediately callthe function
- simply returns a function where the `this` is bound

```js
book.bind(eurowings); //- function
book.bind(eurowings)(234, "Steve Wills"); //Flight EW234 booked by Steve Wills
book.bind(eurowings, 234, "Steve Wills")(); //Flight EW234 booked by Steve Wills

//can as well preset the arguments
```

- Useful when using objects with event listeners

```js
lufthansa.planes = 300;
lufthansa.buyPlane = function () {
  this.planes++;
};

// in event handler function, the `this` points to the element where the event occurs
document.querySelector(".buy").addEventListener("click", lufthansa.buyPlane); //- NaN

//so we need to bind the object as the `this` without immediately running the function
document
  .querySelector(".buy")
  .addEventListener("click", lufthansa.buyPlane.bind(lufthansa)); //- works fine

// Partial application - presetting parameters
const addTax = (rate, value) => value + value * rate;
console.log(0.1, 200); //- 220

const addVAT = addTax.bind(null, 0.23); //not interested in the `this` keyword, but we present one argument to 0.23. So the resulting function only needs one argument

console.log(addVAT(300)); //- works fine

//the order of arguments matters
//it is dfft from setting default params, we create ratther create more specific functions
```

### 8. Immediately Invoked Function Expressions (IIFE)1

- A function thats is executed once and is never called again.
- Common in async JS

```js
const runOnce = function () {
  console.log("I will never run again");
};
runOnce()(
  //turn the logic into an expression and imediately call it
  function () {
    console.log("This will never run again");
  }
)()(
  //or

  () => console.log(`I wion't ever run again`)
)();
```

- Since functions create there own scopes, using IIFE secures the data in the funciton form access by any other code outsd eth efunction

### 9. Closures

> Watch out: Ths is a very misunderstood feature of Javascript

- We donot create closures manually. We don't explicitely use closures. It happens automatically in some situations, we just need to watch for these situations

```js
const secureBooking = function () {
  let passengerCount = 0;

  return function () {
    passengerCount++;
    console.log(`${passengerCount} passengers`);
  };
};

const booker = secureBooking();
booker(); //- 1 passengers
booker(); //- 2 passengers
booker(); //- 3 passengers
booker(); //- 4 passengers

///when we created the `booker` function, the `secureBooking` function finished running, and so was pushed off the stack
// if so then, how is the booker function accessing the `passengerCount` variable to increment, when the function is off the call stack
```

- The environment in whch the variable was created is no longer active, but the function `booker` can still access it. WHAT?
- So a CLOSURE makes a function remember the variable envt in which it was created even longer after its creation ended
- Every function has access to the execution context variable envt in which it was created.
- The closure is this varable environment that follows that function around.
- The scope chain preserves this env't somewhere in the engine.

> _A funcction has acess to the VE of the EC in which it was created_ > _Closure: *the VE attached to the function, exactly as it was at the time and place the function was created*_
> The function keeps a connection with its initial parent scope variables forever

# Working with arrays

### Simple array methods

```js
let arr = ["a", "b", "c", "d", "e"];

// SLICE
arr.slice(2, 9); // return a sub array. Start index and end index
arr.slice(-2); //start from the end
arr.slice(); //make a shallow copy of the array. Call without arguments

// SPLICE
//- mutates the arr. Works like the slice method

// REVERSE - mutates arr
arr.reverse; // reverse the order of element

// CONCAT - join two or more arrays. Doesnt mutate

// JOIN - join the elements uinto one string using the specified seperator

// indexOf, lastIndexOf, push, pop, includes, etc
```

> Normalize searching for the array methods you need to know about

### Looping over arrays: `forEach` method

- takes a callback function and for each iteration calls the function with the `value`, `index` and `array` in that order. You can give them any names

```js
movements.forEach(function(mov, i, a) => {
    if (mov > 0) console.log(`Movement ${i+1}: You deposited ${mov}`)
    if (mov < 0) console.log(`Movement ${i+1}: You deposited ${Math.abs(mov)}`)
})
```

> Note: You can break out of the forEach loop
> Whether you use for...of, for(){} or forEach s up to you

- The forEach method works well with maps and sets

```js
const cur = new Map([
    ['USD', 'US dollar'],
    ['EUR', 'Euro'],
    ['GBP', 'Pound sterling']
])

cur.forEach(function(val, key, map){
    console.log(val,key,map)
})

const curUnique = new Set(['USD', 'GBP', 'USD', 'EUR', 'EUR'])
curUnique.forEach(function(val, key, map){})
//note here the key is the same as values
curUnique.forEach(function(_, val, map))
```

> The underscore is a convention to write throw away variables

> Take a good look at the bankist project and its flowchart, take inspirations and more. The code is available

### Data transformations

1. MAP

- Takes an arr, loops over it, and applies the call back function to each elements and pushes the results to another array
- returns a new arr containing the results of applyingan operation on all original array elements

```js
//convert all els from Euros to US Dollars
movements.map(function (mov) {
  return mov * 1.1;
});
movements.map(function (mov) {
  return mov * 1.1;
});

//or
movements.map((mov) => mov * 1.1);

// we get access to the vaues, current index and entire array
movements.map(function (mov, i, arr) {
  return mov * 1.1;
});
```

2. FILTER

- filters for els in the original arr which satisfy a given condition
- Only passed elements are added to a new arr

```js
movements.filter(mov, i, arr){
    return mov > 0
}

// the call back should return a boolean. Any passed arguments that passes the condition is added to the array to be returned
```

3. REDUCE

- Reduce all els of an array into one single value
- e.g adding the els together
- first argument passed to calback is the accumulator
- 2nd argument is the inital value of the accumulator

```js
movements.reduce(function (acc, cur, i, arr) {
  return acc + cur;

  // always return soemthing to be the next accumulator
}, 0);
```

- Using it to find the maximum value

```js
movements.reduce((acc, mov) => {
  if (acc > mov) return acc;
  else return mov;
}, movements[0]);
```

> One of the most advanced array methods, by far one of the best

> Important
> Array methods that return a new array make t possible to chain array methods

### The `find` method

- retreive one element of an array based on a condition
- returns the first element in the array that satisfies the condition
- e.g.

```js
accounts.find((acc) => acc.owner === "Hiren M"); //- account for Hiren M
```

- The `findIndex` method works similarly but returns the index of matched element

### `some` and `every` methods

- If you need to check if there is any or all vaues satisfy the given condition

```js
movements.some((mov) => mov >= amount * 0.1);
```

### flat and flatMap methods

- `flat` removes nested arrays and flattens the array. Only goes one level deep when flattening by default.
- we can specify the depth as an argument integer

```js
arr = [[[1, 2], 3], [4, [5, 6]], 7, 8];
arr.flat();
arr.flat(2);
```

- `flatMap` is like the `map` method
- Takes in a call back function
- returns a flattened array

### sorting arrays

```js
["Jon", "Zac", "Ada", "Mar"].sort(); //alphabetically

movements.sort(); // still sorts numbers as strings

// pass in a compare function
// return < 0, A,B(keep order)
// return > 0, B,A (switch order)

// sort in ascending order
movement.sort((a, b) => {
  if (a > b) return 1;
  if (b > a) return -1;
});
```

- The sort method mutates the original array

> Important

There are others ways to create and fill arrays ->
`new Array()` constructor, `Array.from()` method

# Numbers, Dates, Intl and Timers

1. Numbers

- In Js, all numbers are represented internally as floating point numbers (i.e 23 === 23.000) and
- The y are stored internally in a 64-base2 format (binary format). Storing data in binary form makes it hard to represent some fractions e.g. 0.1

```js
console.log(0.1 + 0.2); //- 0.30000000000000004
0.1 + 0.2 === 0.3; //- false
```

- Js does alot of rounding to hide this problem, but it still reflects in some cases

- Convert string to a number

```js
//1.
Number("233");

//2.
console.log(+"23"); //- Js does type coercion when it faces the plus operator

//3. parsing number from a string
// get a number from a string that conatians other xters
// Will work only if the string starts with numbers
// 2nd argument specifies the base of the number to be parsed
Number.parsent("30px"); //- 30
Number.parsent("e34"); //- NaN
Number.parsent("34e", 10); //- 34

//parseFloat - reads floating point no
Number.parseFloat("2.5rem"); //- 2.5

//- These functions are global
parseInt("23r"); ///-stills works fine
parseFloat("2.5rem"); //2.5

//4. Ceck if value is NaN
// isNaN - (NaN = Not a Number)
Number.isNaN(20);

//5. Check if value is a number
// isFinite - best way to check if the value is a no or not
Number.isFinite();

//or
Number.isInteger(23.0);
```

### Math and rounding

- methods are part of the `Math` namespace

```js
//1. Squares
Math.sqrt(25)(
  //- 5
  25 ** (1 / 2)
); //- 5

//2. Maximum
Math.max(5, 18, 2); //- 18
//this one also does type coersion, but doesn't do parsing
Math.max(5, 18, "23", 2); //- 23

//3. Minimum
Math.min(5, 18, 2); //- 2

//4. Constants
Math.PI(
  //- 3.141592653589793
  Math.PI * Number.parseFloat("10cm") ** 2
); // area of a circle

//NOTE - remember operator evaluation starts from the right

//5. Random and truncating
Math.random(); // a random no. btn 0 and 1
Math.trunc(Math.random() * 6) + 1; //random no btn 1 and 6

///usage
function randomInt(min, max) {
  return Math.trunc(Math.random() * (max - min) + 1);
}

//6. Rounding
Math.trunc(23.33); // remove any decimals
Math.round(23.9); //- 24 //rounds the number to the nearest int
Math.ceil(23.6); //- 24 //rounds up to the nearest int
Math.floor(23.6); //- 23 //rounds down

//trunc Vs floor
Math.trunc(-23.3); //- 23
Math.floor(-23.3); //24
```

> `Math.trunc()` and `Math.floor()` work similar when dealing with positive numbers but work dfft when dealing with negatives
> `Math.floor()` is more reliable since it works in both positive and negative conditions

```js
// Rounding decimals
(2.7)
  .toFixed(0)(
    //- '3'
    2.7
  )
  .toFixed(3) + //- '2.700'
  //toFixed returns a str
  (2.345).toFixed(2); //- 2.35
```

> Note

Remember Numbers are still primitives. They appears to have methods because under the hood, Js does boxing. I.e It converts the numbers and strings into objects to provide it with methods. Afterwards, they are conveted back to primitives.

### The remainder operator (%)

```js
(5 % 2) //- 1
(8 % 3) //- 2
(6 % 2) //- 0

//1. check whether a no is even or not
const isEven = n => n % 2 === 0
isEven(8) //- true
isEven(9) //- false

//2. check if numbers are divisible
//- if the result of the remainder is zero

//3. Every Nth time
[...document.querySelector('.row')].forEach((row, i) => {
  if(i % 2 === 0) //every even row
  if (i % 2 !== 0) //every odd row
  if (i % 3 === 0) //every third row, etc
})
```

### BigInt

- a special tyoe of integers
- numbers are represented as 64 bits. meaning there are only 64 1's and 0's avaible to represent the number
- Of these 64bits, only 53 are used to represent the digits themselves, the rest are left to represent decimal point and the sign
- There's a limit to the biggest number that Js can safely represent

```js
2 ** 53 - 1; //- 9007199254740991 // minus 1 because 0 is also a number
Number.MAX_SAFE_INTEGER;

//bigger than this, the accuracy s not reliable
```

- If we deal with very big numbers, we need to use BigInt to store these numbers
- Append an 'n' to the number

```js
console.log(98765432123456788765n); //-98765432123456788765n
BigInt(98765432123456788765); //- this function has some problems

//Operations
// All the operators work same to smaller numbers(*+/-%)
```

> We can not mix BigInt with other types. You have to first convert other types to BigInt
> That is where the BigInt() function becomes necessary

> There are some exceptions to this rule of 'cannot operate BigInt and other types at the same time'
> Comparison operators(>,<,>=,<=) and string concatenation(+)

> The Math methods dont work on BigInt

> With BigInt divisions, the result is a rounded to the nearest BigInt

## Dates and Times

- Four ways of creating dates using `new Date()`. It returns a date string

```js
//no args
new Date(); //return date now

// parse date from astring
new Date("Aug 02 2020 18:04:23");
new Date("Dec 25, 2025");
new Date("2019-11-18T21:31:17.178Z");

// pass numbers in yyyy,mm,dd,hh,mm,ss
new Date(2037, 10, 19, 15, 23, 5);

// pass number of ms since Jan 01 1970
new Date(0); //- Thu Jan 01 1979 --> The start of unix time
```

> Months in JS are zero-based
> Js autocorrects dates based on number of days in each month

- Working with dates

```js
const future = new Date(2037, 10, 24, 15, 23);

//1. year
future.getFullYear(); //- 2037
// never use .getYear()

//2. Date (of the month)
future.getMonth(); //- 10
future.getDate(); //- 24

future.getDay(); //- day of the week
future.getHours();
future.getMiniutes();
future.getSeconds();

// get a string, that is universal(not zone related)
future.toISOString(); //-

// time stamp
future.getTime(); //- get no of ms passed since Jan/1/1970

//timestamp for right now
Date.now();
```

> For each of these methods, there is a set version eg. `.setFullYear()`

```js
//usage example
const now = new Date();
const day = `${now.getDate()}`.padStart(2, 0); //add a zero if it is one digit
const month = `${now.getMonth()}`.padStart(2, 0);
const year = now.getFullYear();
const hour = getHours();
const minutes = getMinutes();
```

### Operations with dates

- we can convert dates to numbers using the `Number()` function or appeding a (+)
- When we do ops on dates, the reult is the timesatams. We can do ops on this tmestamp too

```js
const future = new Date(2037, 10, 19, 15, 23);
console.log(+future); //timestamp
console.log(Number(future)); //timestamp

const calcDaysPassed = (date1, date2) =>
  Math.abs((date2 - date1) / (1000 * 60 * 60 * 24));
//number of ms in a day = 1000ms * 60s * 60min * 24hr
```

> If you need precise calculations, use a library like `moment.js`

- A nice use case: Timelapse

```js
//today, yesterday, 3days ago, 1 week ago, 2weeks ago, 1 month ago, 1 yr ago
const calcDaysPassed = (date1, date2) =>
  Math.round(Math.abs(date2 - date1) / (1000 * 60 * 60 * 24));

const daysPassed = calcDaysPassed(new Date(), date);

if (daysPassed === 0) return "Today";
if (daysPassed === 1) return "Yesterday";
if (daysPassed < 7) return `${daysPassed} days ago`;
if (daysPassed === 7) return "1 week ago";
else {
  // return actual date
  const day = `${date.getDate()}`.padStart(2, 0);
  const month = `${date.getMonth() + 1}`.padStart(2, 0);
  const year = date.getFullYear();

  return `${day}/${month}/${year}`;
}
```

## Internationalisation API(intl): Dates

- allows to format adtes as strigns accoording to different time zones / langauges
- We can support different languages and parts of the world
- The API is used to internationalise many other things(currency, direction, etc) but her we'll focus on dates
- Use the `Intl.DateTimeFormat()` constructor
- Takes a first argument of the locale string eg 'en-US', 'ch', 'fr'
- Pass the date to format into the chained `.format()` function

```js
new Intl.DateTmeFormat("en-US").format(Date.now()); //- 8/12/2023
new Intl.DateTmeFormat("en-GB").format(Date.now()); //- 12/08/2023
```

> To get the local strings, google "iso language code table"
> [lingoes](lingoes.net) is easier to understand

- we can provide more customizations using an options object, which is passed as a second argument

```js
const now = new Date()
const options = {
  hour: 'numeric',
  minute: 'numeric',
  day: 'numeric',
  month: 'long' // 2-digit, short, numeric, narrow
  year: 'numeric' // 2-digit
  weekday: 'long'
}
new Intl.DateTimeFormat('pt-PT', options).format(now)
```

> The API changes languages and font styles of dates accordingly

- Gettng the locale automatically form the user's browser

```js
const locale = navigator.language;
```

> Remember to read about the Intl API in the MDN documentation, to find the several other methods it uses

## Internationalising numbers

```js
const num = 3884764.23
  new Intl.NumberFormat('en-US').format(num) //- 3,884,764.23
  new Intl.NumberFormat('de-DE').format(num) //- 3.884.764,23
  new Intl.NumberFormat('ar-SY').format(num) //- in arabic

const options = {
  style: 'unit', //percent | currency,
  currency: 'EUR' //if style: 'currency'
  unit: 'mile-per-hour'
  useGrouping: false //turn separators on and off
}
  new Intl.NumberFormat('en-US', options).format(num) //- 3,884,764.23 mph
  new Intl.NumberFormat('de-DE', options).format(num) //- 3.884.764,23 mi/h
  new Intl.NumberFormat('ar-SY', options).format(num) //- in arabic

```

## Timers

- 2 kinds;
- `setTimeout` runs once
- `setInterval` runs over and over again
- The timer receives a call backfunction as first argument that runs after the specified delay as 2nd argument(in milliseconds)
- Note: Timers are asynchronous in nature. AsyncJs is discussed later
- All the arguments passed into the timer after the delay, are passed to the callback when it is called, in the same order

```js
setTimeout(
  (ing1, ing2) => console.log(`Here's your ${ing1} and ${ing2} pizza`),
  3000,
  "olives",
  "spinach"
); //- `Here's your olives and spinach pizza

//stopping the timer, before it runs
const ings = ["olives", "spinach"];
const pizzaTimer = setTimeout(
  (ing1, ing2) => console.log(`Here's your ${ing1} and ${ing2} pizza`),
  3000,
  ...ings
);

if (ings.includes("spinach")) clearTimeout(pizzaTimer);
```

- setInterval, and logout timer

```js
setInterval(() => console.log(new Date()), 1000); //- prints current time every second

//usage - logout timer

let logoutTimer;

function startLogoutTimer() {
  //set time to 5 mins in sec
  let timeout = 5 * 60;

  const lblTimer = document.querySelector(".timer");

  function tick() {
    lblTimer.textContent = timeout; //display the timeout

    //get mins and the remainder seconds
    const min = String(Math.trunc(time / 60)).padStart(2, 0);
    const sec = String(time % 60).padStart(2, 0);

    //watch for when the time elapses
    if (timeout === 0) {
      clearInterval(logoutTimer);
      //run logout functionality
    }

    timeout--; //every iteration, reduce the timeoout by one second
  }

  const logoutTimer = setInterval(tick, 1000);
  tick(); //don't wait for the first one second to end to run the tick function. We need it to immediately set the time in the page

  return logoutTimer; //so tht  we can check if there is a timer running when we login
}

//on login, call the function --> startLogoutTimer()
//when we login
if (timer) clearInterval(timer);
timer = startLogoutTimer();

//implement code to reset the timer whenever the user is still busy with the page
```

# Advanced DOM and Events

## How the DOM works

- It is the interface btn JS and the html page in the browser
- Allows us to make Js interact with the browser
- We can write Js to create, modfy, and delete HTML elements, set styles, classes, and attributess; and listen and respond to events
- The DOM tree is generated from an HTML document, which we can then interact with.
- The DOM is a very complex APII that contains alot of methods and properties to interact with the DOM tree

> The DOM tree is made of nodes, which represent each element, and content
> There are dfft types of nodes: HTML els or text

- Every node in the DOM tree is of the type: node.
- Each node is represented in Js by an object, that gets access to special node methods and properties e.g. `.textContent`, `childNodes`, `.cloneNode()`, etc

- The `NODE` type has the child nodes: Element, Text, Comment, Document types
- i.e even text in a <p> gets it owns node. Same for comments.
- The element type of node gives each HTML element el access to many useful methods and properties e.g. `innerHTML`, `classList`, `children`, `append()`, `remove()`, `insertAdjacentHTML()`, and many more
- The element type contains a(only one) more specific type, any of HTMLButtonElement, HTMLDivElement, etc.
- Each HTMLElement has special methods and properties dfft from any other one. Eg. the HTMLImgElement has a `src` property

> Inheritance: all the child nodes will get access to the properties and methods from its parents and ancestor

- There is a special node type: EventTarget. It allows us to add event listeners on any element

## Selecting, creating, deleting elements

```js
//selecting the document element, special elements
document.documentElement;
document.head;
document.body;

//selecting using selectors
document.querySelector("<selector>"); //returns the first match

//multiple(node list)
document.querySelectorAll("<selector>"); // returns node list of the matches

//other methods
document.getElementById("id");
document.getElementsByTagName("button"); // returns an HTMLCollection
document.getElementsByClassName("btn");
```

> An HTMLCollection is a live collection. Means if the DOM changes, this collection is automatically updated

> A Node list is not automatically updated.

- Creating and inserting

```js
//1 .insertAdjacentHTML()
dotContainer.insertAdjacentHTML(
  "beforeend", //beforebegin, afterbegin, afterend
  `<button class="dots__dot" data-slide="1"></button>`
);

//2.
const el = document.createElement("div"); //creates a DOM object, stores it in the var

///we can work with this object like a normal selection
el.classList.add("cookie-msg");
el.textContent = `This site uses cookies`;
el.innerHTML = `We use cookies.
              <button class="btn btn--close-cookie">Got it</button>
`;

///time to inset it into the DOM
const header = document.querySelector(".header");
header.prepend(el); //prepend adds it as first child
header.append(el); //adds it as last

//we can use the append and prepend methods to also  move elements
//when we use these methods, the specified element s moved from whereevr it is to where it is being placed

//DOM els are unique and can only be at one place at a time
// to insert multiple copies of the same el; we first clone it before inserting it
header.append(el.cloneNode(true)); //- true = also clone child elements

//before and after - inserts the el as a sibling
header.before(el);
header.after(el);

// Delete elements -> remove()
el.remove(); //1.

el.parentElement.removeChild(el); //2
```

## Styles, attributes, classes

1. Styles

```js
// These are added as inline styles
el.style.backgroundColor = "#37383d";
el.style.width = "120%";

///getting the styles
console.log(el.style.color); // nothing - if it is not an inline-style

// getComputedStyle global function
console.log(getComputedStyle(el));
console.log(getComputedStyle(el).color);

//2. CSS ustom propertes
// declared in the :root{}, which is equivalent to document element
// setProperty()
document.documentElement.style.setProperty("--color-primary", "orangered");
```

2. Attributes

```js
const img = document.querySelector(".img");
//for standard attrs
img.alt;
img.src;
img.logo;
img.className;

// non standard
img.getAtribute("designer-info");

// Data attributes

///<img src="path/to/logo.png" class=".logo" data-version="3.0" data-api-name="hiren1699">

const img = document.querySelector(".logo");
img.dataset.version; //- 3.0
img.apiName; //- hiren1699
```

> `img.src` returns an ansolute url while `img.getAttribute('src')` returns the relative url as it is in the html
> The same applies for the a:links in some cases

- Classes

```js
logo.classList.add("class-name", "2nd");
logo.classList.remove("that", "this");
logo.classList.toggle("class-name");
logo.classList.contains("class");
```

## Smooth scrolling - Bankist

1. Method 1 - old school

```js
const btn = document.querySelector(".btn-scroll-to"); //clcik this to go to the section
const section1 = document.querySelector("#section1"); //section to scroll to

btn.addEventListener("click", function (e) {
  const coords = section1.getBoundingClientRect;
});

// scrolling
window.scrollTo(); //1st arg = left position, 2nd arg = top positon
window.scrollTo(0, coords.top); //remember the coords are relative to the viewport
///add the current scroll to the top position
window.scrollTo(
  coords.left + window.pageXOffset,
  coords.top + window.pageYOffset
);

// make it smoother
///pass in an options object instead
window.scrollTo({
  left: coords.left + window.pageXOffset,
  top: coords.top + window.pageYOffset,
  behaviour: "smooth",
});
```

> The results of the getBoundingClientRect() function. It is relative to the visible viewport

```js
{
  x: 0, //distance from left of the browser
  y: 588, //distance from  top
  right: 142.4,
  left: 0,
  top: 168,
  bottom: 1983,
  height: ,
  width:
}

// current scroll positon
window.pageXOffset
window.pageYOffset

// dimensions of viewport
document.documentElement.clientHeight
document.documentElement.clientWidth
```

2. Method 2 - newer

```js
btn.addEventListener("click", function (e) {
  sectiion1.scrollIntoView({
    behaviour: "smooth", // 'auto' | 'smooth'
  });
});
```

## Types of Events and Event handlers

### Events

- Events are signals generated when something happens in the page.
- They always happen, we just need to listen to them

```js
const h1 = document.querySelector("h1");
h1.addEventListener("mouseenter", function (e) {
  //'mouseenter' = hover
});

//2. `onevent` property
///for every event there is this property
h1.onclick = function (e) {};
h1.onmouseenter = function (e) {};
```

> `addEventListener` is better than the `onevent` properties b'se

    1. It allows us to multiple listeners to the same event
    2. We can remove an eventHandler if we nolonger need it to

```js
const doSomeThing = function (e) {};
h1.addEventListener("click", doSomeThing);

setTimeout(() => h1.removeEventListener("click", doSomeThing), 3000);
```

> There's another way of registering eventListeners: In the html code using the `onevent` attribute. This is not good practice

- Events reference
- check the MDN documentation

  1. Resource events

  - error
  - abord
  - load
  - beforeunload
  - unload

  2. Network events

  - online
  - offline

  3. Focus events

  - focus
  - blur
  - focusin
  - focusout

  4. Websocket events

  - pagehide
  - pageshow
  - popstate

  5. CSS Animation events

  - animationstart
  - animationcancel
  - animationend
  - animationiteration

  6. CSS Transtion events

  - transitionstart
  - transitionscancel
  - transitionsend

  7. Form events

  - reset
  - submit

  8. Printing events

  - beforeprint
  - afterprint

  9. Text composition evnts

  - compositionstart
  - compositonupdate
  - compositionend

  10. view events

  - fullscreenchange
  - fullscreenerror
  - resize
  - scroll

  11. Clipboard

  - cut
  - copy
  - paste

  12. Keyboard

  - keydown
  - keyup
  - keypress

  13. Mouse

  - auxclick
  - click
  - contextmenu
  - dblclick
  - mousedown
  - mouseenter
  - mouseleave
  - mousemove
  - mouseover
  - mouseout
  - mouseup
  - pointerlockchange
  - pointerlockerror
  - select
  - wheel

  14. Drag n Drop

  - drag
  - dragend
  - dragenter
  - dragerror
  - dragleave
  - dragover
  - drop

  15. Media

  - audio
  -

  16. Progress
  17. Storage
  18. Update
  19. Value change

  - So many more.

## Event Propagation: Bubbling and Capturing

- When an action happens on an elements(e.g. a click on anchor element), the DOM generates a click event immediately.
- However the event is not generated on the element where it occured, It is generated on the root of the document( At the top of the dom tree)

1.  Captuirng phase

- The _Capturing Phase_ happens where the event propagates from the top. It passes through every parent until it reaches the target

2.  Target phase

- The _Target phase_ occurs. This is when the event listener is called

3.  Bubbling phase

- The event then propagates from the target up to the top of the document. The event _Bubbles up_

> This allows us to add event listeners on parents to handle events of their children

> _By default, the event listeners lsiten for events in the Target and Bubbling phases only_

> We can however change this behaviour to handle events in the capturing phase instead

> Not all events have bubbling and capturing phases

- Example of event propagation

```js
const randomInt = (min, max) => Math.floor(Math.random() * (max - min) + min);

const randomColor = () =>
  `rgba(${randomInt(0, 255)}, ${randomInt(0, 255)}, ${randomInt(0, 255)})`;

document.querySelector(".nav__link").addEventListener("click", function (e) {
  this.style.backGroundColor = randomColor; //points to target el

  e.target; //- el where the event originated

  e.stopPropagation(); //stop event from propagation
});
```

> If there are event handlers on many of the parents, a click on only one child element trggers the handlers on all the parents(bubbling phase).

> If the parent is the target, the children donot react to the event, evenif they have handlers

> The Bubbling phase is important to do event delegation

- Change the behaviour to react to events in capturing: Pass `true` as third arg to the `addEventListener` method

> Note: Don't stop Proppagation and don't the default propapagation behaviour

## Event delegation: Implementing smooth navigation

- Anchors with a hash link scroll to the section with that id

```html
<a href="#one">Services</a>
<a href="#two">About</a>
<a href="#three">Contact</a>

<section id="#one">
  <section id="#two">
    <section id="#three"></section>
  </section>
</section>
```

1. Without delegation

- attaching the same function to each el is not practical, esp if there are 1000's of elements in the list

```js
document.querySelectorAll(".nav__link").forEach(function (el) {
  el.addEventListener("click", function (e) {
    e.preventDefault(); //stop the default navigating behaviour

    const id = this.getAttribute("href");
    document.querySelector(id).scrollIntoView({
      behaviour: "smooth",
    });
  });
});
```

2. Delegation

- Add event listener to common parent
- determine on which element the event originated

```js
document.querySelector(".nav__links").addEventListener("click", function (e) {
  //common parent

  //matching only wanted children
  if (e.target.classList.contains("nav__link")) {
    e.preventDefault(); //stop the default navigating behaviour
    const id = e.target.getAttribute("href");
    document.querySelector(id).scrollIntoView({
      behaviour: "smooth",
    });
  }
});
```

> Event delegation also applies when adding event listeners to elements that are not in the source code or those that aren't yet present in the DOM. E.g els that are dynamically added.

## DOM traversing

- Walking through the DOm
- Selecting one element based on another element

```js
const h1 = document.querySelector("h1");

//1. downwards - direct children
h1.querySelector(".highlight");

h1.childNodes; //returns a bunch of nodes: text, comments, els
h1.children; //all child element nodes
h1.firstElementChild.style.color = "color"; //first child
h1.lastElementChild.style.color = "orangered"; //last chld

//2. Going upwards
h1.parentNode; //direct parent
h1.parentElement; //returns the same

///parent el, not necessarily direct parent
h1.closest(".header"); //takes in a selector string
h1.closest("h1"); //returns the el itself :D

//3. Sideways: siblings
h1.previousElementSibling; //el that comes before
h1.nextElementSibling; //el that comes before

///sibling nodes
h1.previousSibling;
h1.nextSibling;

///select all siblings
h1.parentElement.children;
```

## Tabbed component

```html
<section class="section" id="section--2">
  <div class="section__title">
    <h2 class="section__description">Operations</h2>
    <h3 class="section__header">
      Everything as simple as possible, but no simpler.
    </h3>
  </div>

  <!--Component start-->
  <div class="operations">
    <div class="operations__tab-container">
      <button
        class="btn operations__tab operations__tab--1 operations__tab--active"
        data-tab="1"
      >
        <span>01</span>Instant Transfers
      </button>
      <button class="btn operations__tab operations__tab--2" data-tab="2">
        <span>02</span>Instant Loans
      </button>
      <button class="btn operations__tab operations__tab--3" data-tab="3">
        <span>03</span>Instant Closing
      </button>
    </div>
    <div
      class="operations__content operations__content--1 operations__content--active"
    >
      <!-- The link tab is in the data-tab attribute-->
      <div class="operations__icon operations__icon--1">
        <svg>
          <use xlink:href="img/icons.svg#icon-upload"></use>
        </svg>
      </div>
      <h5 class="operations__header">
        Tranfser money to anyone, instantly! No fees, no BS.
      </h5>
      <p>
        Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
        tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim
        veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea
        commodo consequat.
      </p>
    </div>

    <div class="operations__content operations__content--2">
      <div class="operations__icon operations__icon--2">
        <svg>
          <use xlink:href="img/icons.svg#icon-home"></use>
        </svg>
      </div>
      <h5 class="operations__header">
        Buy a home or make your dreams come true, with instant loans.
      </h5>
      <p>
        Duis aute irure dolor in reprehenderit in voluptate velit esse cillum
        dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
        proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
      </p>
    </div>
    <div class="operations__content operations__content--3">
      <div class="operations__icon operations__icon--3">
        <svg>
          <use xlink:href="img/icons.svg#icon-user-x"></use>
        </svg>
      </div>
      <h5 class="operations__header">
        No longer need your account? No problem! Close it instantly.
      </h5>
      <p>
        Excepteur sint occaecat cupidatat non proident, sunt in culpa qui
        officia deserunt mollit anim id est laborum. Ut enim ad minim veniam,
        quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
        consequat.
      </p>
    </div>
  </div>
</section>
```

```css
.operations__tab--active {
  /* Lift up the ative tab a bit */
  transform: translateY(-66%);
}

.operations__content {
  /* Hide any content by default */
  display: none;
}

.operations__content--active {
  /* if active, display the content n apply the styles to it*/
  /* change display property to something that is not 'none' */
  display: grid;
  grid-template-columns: 7rem 1fr;
  column-gap: 3rem;
  row-gap: 0.5rem;
}
```

```js
//1. Select the tabs, the Tabs container, and the content containers
const tabs = document.querySelectorAll(".__tab"); //select all the tabs(buttons)

const tabsContainer = document.querySelector(".__tab-container");

const tabsContent = document.querySelectorAll("__content"); //all the content contr's

//2. Add click event handlers on the tabs
tabsContainer.addEventListener("click", (e) => {
  const clicked = e.target.closest(".__tab"); // select the button even if it was an child of the button that clicked, i.e dfft 'e.target's

  if (!clicked) return; //gaurd close, in case the closest method returns no match(null)

  tabs.forEach((tab) => tab.classList.remove("__tab--active")); //first deactivate all tabs
  clicked.classList.add("__tab--active"); //add active class to activated tab
});

//3. Activate the right content
tabsContent.forEach((c) => c.classList.remove("__content--actiive")); //first hide all content
document
  .querySelector(`.__content--${clicked.dataset.tab}`)
  .classList.add("__content--active");
```

## Passing argumanets to event handlers: Hover over an element to fade all the rest(Bankist nav)

```js
//menu fade animation
const handleHover = function (e, opacity) {
  if (e.target.classList.contains("nav__link")) {
    //select the els(links, sblings of the hovered link, imgs)
    const clickedLink = e.target;
    const siblings = clickedLink.closest(".nav").querySelectorAll(".nav__link");
    const logo = clickedLink.closest(".nav").querySelector("img");

    siblings.forEach((el) => {
      if (el !== clikcedLink) el.tyle.opacity = this;
    });
    logo.style.opacity = this;
  }
};

const nav = document.querySelector(".nav");

//we need to pass args into the function
//1.
nav.addEventListener("mouseover", function (e) {
  handleHover(e, 0.5);
});
nav.addEventListener("mouseover", function (e) {
  handleHover(e, 1);
});

//2.
nav.addEventListener("mouseover", handleHover.bind(0.5));
nav.addEventListener("mouseover", handleHover.bind(1));
```

## Implementing sticky navigation: Scroll Event

- We make the nav sticky by adding the `sticky` when we reach a certain point on scroll
- ```css
  .sticky {
    position: fixed;
    backgroud-color: rgba(255, 255, 255, 0.9); /*add some transparency */
  }
  ```

  - 1. Using scroll event

  ```js
  const s1 = document.querySelector("#sect1");
  const initCoords = s1.getBoundingClientRect();
  window.addEventListener("scroll", function (e) {
    if (window.scrollY > initCoords.top) nav.classList.add("sticky");
    else nav.classList.remove("sticky");
  });
  ```

  > Using the scroll event is not an efficient practice. It is better to sue the Intersection Observer API.

## The Intersetion Observer API

- Allows Js to observe elements for when they intersect with other elements and th viewport
- Usage

```js
const obsCallback = function (entries, observer) {
  entries.forEach((entry) => {});
};
const observer = new IntersectionObserver(obsCallback, {
  root: null, //the el that the target  intersects, 'null' = viewport
  threshold: [0, 0.2], //0.1, // %age of intersection val | [...values]
});

observer.observe(sect1); //pass in the htmlEL
```

- Sticky nav
- When the header moves completely out of view

```js
const header = document.querySelector(".header");
const navHeight = nav.getBoundingClientRect().height;

const stickyNav = function (entries) {
  const [entry] = entries;

  if (!entry.isIntersecting) nav.classList.add("sticky");
  else nav.classList.remove("sticky");
};

const headerObserver = new IntesectionObserver(stickyNav, {
  root: null, //root=viewport
  threshold: 0,
  rootMargin: `-${navHeight}px`, //a box of 90px added before intersection
});
```

## Reveal elements on scroll: Intersection Observer

- Observing multiple els

- Can easily be implemented without using an external library

- All sections by default have a class that hides them, and slightly displaces them so they can slide in when the class is removed. We can hide them using Js
- Add a transiton property to the section

```css
.section__hidden {
  opacity: 0;
  transform: translateY(8rem);
}
```

```js
const revealSection = function (entries, observer) {
  const [entry] = entries; //there's one threshold

  if (!entry.isIntersecting) return;
  entry.target.classList.remove("section__hidden");

  //after sections ahve revealed, stop the observing
  observer.unobserve(entry.target);
};
const allSections = document.querySelectorAll("section");

const sectionObserver = new IntesectionObserver(revealSection, {
  root: null,
  threshold: 0.15,
});

allSections.forEach(function (section) {
  section.classList.add("section__hidden");
  observer.observe(section);
});
```

## Lazy loading images

- To optmize the performance of loading of the page. This increases the site performance.

- In the HTML, we have a very low resolution image wc is really small and is loaded in the beginning (approx. 200x120, 15kb).

- The unclear img is blurred using the `lazy-img` class

  ```css
  .lazy-img {
    filter: blur(20px);
  }
  ```

- The real image is reference in the `data.src` attribute

```js
// lazy loading
//1. select only images you want to lazy load
const imgTargets = document.querySelectorAll("img[data-src]");

ont loadImg = function(entries, observer){
  const [entry] = entries

  if(!entry.isIntersecting) return

  //replace place holder img
  entry.target.src = entry.target.dataset.src

  //clear the blur on load
  entry.target.addEventListener('load', function(e){
    entry.target.classList.remove('lazy-img')
  })

  // stop obseving when loading is done
  oberserve.unobserve(entry.target)
}

const imgObserver = new IntersectionObsever(loadImg, {
  root: null,
  threshold: 0,
  rootMargin: '200px' //make imgs load before the intersection
})
```

## Slider component

- There is a slider componet that contains slides and dots and buttons
- Sliides are placed side by side, using `transform: translateX()`
- The slides are stacked on top of each other, but JS sts the initial transforms

```html
<div class="slider">
  <div class="slide">
    <div class="testimonial">
      <h5 class="testimonial__header">Best financial decision ever!</h5>
      <blockquote class="testimonial__text">
        Lorem ipsum dolor sit, amet consectetur adipisicing elit. Accusantium
        quas quisquam non? Quas voluptate nulla minima deleniti optio ullam
        nesciunt, numquam corporis et asperiores laboriosam sunt, praesentium
        suscipit blanditiis. Necessitatibus id alias reiciendis, perferendis
        facere pariatur dolore veniam autem esse non voluptatem saepe provident
        nihil molestiae.
      </blockquote>
      <address class="testimonial__author">
        <img src="img/user-1.jpg" alt="" class="testimonial__photo" />
        <h6 class="testimonial__name">Aarav Lynn</h6>
        <p class="testimonial__location">San Francisco, USA</p>
      </address>
    </div>
  </div>

  <div class="slide">
    <div class="testimonial">
      <h5 class="testimonial__header">
        The last step to becoming a complete minimalist
      </h5>
      <blockquote class="testimonial__text">
        Quisquam itaque deserunt ullam, quia ea repellendus provident, ducimus
        neque ipsam modi voluptatibus doloremque, corrupti laborum. Incidunt
        numquam perferendis veritatis neque repellendus. Lorem, ipsum dolor sit
        amet consectetur adipisicing elit. Illo deserunt exercitationem
        deleniti.
      </blockquote>
      <address class="testimonial__author">
        <img src="img/user-2.jpg" alt="" class="testimonial__photo" />
        <h6 class="testimonial__name">Miyah Miles</h6>
        <p class="testimonial__location">London, UK</p>
      </address>
    </div>
  </div>

  <div class="slide">
    <div class="testimonial">
      <h5 class="testimonial__header">Finally free from old-school banks</h5>
      <blockquote class="testimonial__text">
        Debitis, nihil sit minus suscipit magni aperiam vel tenetur incidunt
        commodi architecto numquam omnis nulla autem, necessitatibus blanditiis
        modi similique quidem. Odio aliquam culpa dicta beatae quod maiores ipsa
        minus consequatur error sunt, deleniti saepe aliquid quos inventore
        sequi. Necessitatibus id alias reiciendis, perferendis facere.
      </blockquote>
      <address class="testimonial__author">
        <img src="img/user-3.jpg" alt="" class="testimonial__photo" />
        <h6 class="testimonial__name">Francisco Gomes</h6>
        <p class="testimonial__location">Lisbon, Portugal</p>
      </address>
    </div>
  </div>

  <button class="slider__btn slider__btn--left">&larr;</button>
  <button class="slider__btn slider__btn--right">&rarr;</button>
  <div class="dots"></div>
</div>
```

```css
/* SLIDER */
.slider {
  max-width: 100rem;
  height: 50rem;
  margin: 0 auto;
  position: relative;

  /* IN THE END */
  overflow: hidden; /**Hide all the overflowing slides */
}

.slide {
  position: absolute;
  top: 0;
  width: 100%;
  height: 50rem;

  display: flex;
  align-items: center;
  justify-content: center;

  /* THIS creates the animation! */
  transition: transform 1s;
}

.slide > img {
  /* Only for images that have different size than slide */
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.slider__btn {
  position: absolute;
  top: 50%;
  z-index: 10;

  border: none;
  background: rgba(255, 255, 255, 0.7);
  font-family: inherit;
  color: #333;
  border-radius: 50%;
  height: 5.5rem;
  width: 5.5rem;
  font-size: 3.25rem;
  cursor: pointer;
}

.slider__btn--left {
  left: 6%;
  transform: translate(-50%, -50%);
}

.slider__btn--right {
  right: 6%;
  transform: translate(50%, -50%);
}

.dots {
  position: absolute;
  bottom: 5%;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
}

.dots__dot {
  border: none;
  background-color: #b9b9b9;
  opacity: 0.7;
  height: 1rem;
  width: 1rem;
  border-radius: 50%;
  margin-right: 1.75rem;
  cursor: pointer;
  transition: all 0.5s;

  /* Only necessary when overlying images */
  /* box-shadow: 0 0.6rem 1.5rem rgba(0, 0, 0, 0.7); */
}

.dots__dot:last-child {
  margin: 0;
}

.dots__dot--active {
  /* background-color: #fff; */
  background-color: #888;
  opacity: 1;
}
```

- We are only concered with the `.slider`, `.slide`, the content maybe anything

```js
// Slider

//1. elements
const slides = document.querySelectorAll(".slide");
const btnLeft = document.querySelector(".slider__btn--left");
const btnRight = document.querySelector(".slider__btn--right");

//2. Set initial position
// place them side by side initially
slides.forEach((s, i) => (s.styl.transform = `translateX(${100 * i}%)`));

//3. Next slide
let currentSlide; //keep track of the current slide for use by many other functions
const maxSlide = slides.length; //no of slides

btnRight.addEventListener("click", function () {
  currentSlide++;

  if (currentSlide === maxSlide - 1) {
    currentSlide = 0;
  } else {
    currentSlide++;
  }

  slides.forEach(
    (s, i) => (s.style.transform = `translateX(${100 * (i - currentSlide)}%)`)
  );
  ///exp: if currentSlide=1 (0, 100, 200, 300). The btnRight produces -100, 0, 100, 200
});
```

- Refactoring the code, into functions

```js
///////////////////
let currentSlide;
const maxSlide = slides.length;
//refactor
const goToSlide = function (slide) {
  slides.forEach(
    (s, i) => (s.style.transform = `translateX(${100 * (i - slide)}%)`)
  );
};

//2. Set initial position
goToSlide(0);
activateDot();
//3. Next slide

const nextSlide = function () {
  currentSlide++;

  if (currentSlide === maxSlide - 1) currentSlide = 0;
  else currentSlide++;

  goToSlide(currentSlide);
  activateDot(currentSlide);
};

const prevSlide = function () {
  if (currentSlide === 0)
    currentSlide = maxSlide - 1; //maxSlide is not zeo based
  else currentSlide--;

  goToSlide(currentSlide);
  activateDot(currentSlide);
};

btnRight.addEventListener("click", nextSlide);
btnLeft.addEventListener("click", prevSlide);

//4. Adding keyboard events
document.addEventListener("keydown", function (e) {
  // if(e.key === 'ArrowLeft') prevSlide()
  // if(e.key === 'ArrowRight') nextSlide()
  //or
  e.key === "ArrowLeft" && prevSlide();
  e.key === "ArrowRight" && nextSlide();
});

//5. Dots
const dotsContainer = document.querySelector("dots__container");

const createDots = function () {
  slides.forEach((_, i) => {
    dotsContainer.insertAdjacentHTML(
      "beforeend",
      `<button class="dots__dot" data-slide=${i}></button>`
    );
  });
};

createDots();

///Attach event handler to the dot container
dotContainer.addEventListener("click", function (e) {
  if (!e.target.classList.contains("dots__dot")) return;
  const { slide } = e.target.dataset;
  goToSlide(slide);
  activateDot(slide);
});

///active dot
function activateDot(slide) {
  document
    .querySelectorAll(".dots__dot")
    .forEach((dot) => dot.classLit.remove("dots__dot--active"));

  document
    .querySelector(`.dots__dot[data-slide="${slide}"]`)
    .classList.add("dots__dot--active");
}
```

> Write an init function to call all the initial functions

```js
const init = function () {
  goToSlide(0);
  createDots();
  activateDot(0);
};

init();
```

> We should export this slider functionaliity n its own function then we call that function. To avoid polluting the global namespace.

> We can also accept an options object argument into the function, and work with them. E.g. select the option of auto scroll, dots, etc

- The styles creating the buttons

```css
.dots {
  position: absolute;
  bottom: 5%;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
}

.dots__dot {
  border: none;
  background-color: #b9b9b9;
  opacity: 0.7;
  height: 1rem;
  width: 1rem;
  border-radius: 50%;
  margin-right: 1.75rem;
  cursor: pointer;
  transition: all 0.5s;

  /* Only necessary when overlying images */
  /* box-shadow: 0 0.6rem 1.5rem rgba(0, 0, 0, 0.7); */
}

.dots__dot:last-child {
  margin: 0;
}

.dots__dot--active {
  /* background-color: #fff; */
  background-color: #888;
  opacity: 1;
}
```

## Life cycle DOM events

- The events that occur in the DOM during the pages life cycle

  1. DOMContentLoaded

  - Fires when the HTML is completel pased. All scripts must be downloaded and executed b4 it fires.
  - It doesnot wait for images, etc
  - If we have the script tag at the end of the body, no need to listen to events

  ```js
  document.addEventListener("DOMContentLoaded", function (e) {});
  ```

  2. load

     - When all resources ahve been fully loaded
     - Happens on `window`

  3. beforeunload

     - Fires immediately before the user exits the page

     ```js
     window.addEventListener("beforeunload", function (e) {
       e.preventDefault();
       e.returnValue = "";
     });
     ```

     - This one is annoying and should be used when really necessary: when data may be lost

## Efficient Script Loading: defer and async

- We can add the async and defer attributes when declaring the script tag,which affects the way the Js is loaded
- DEFAULT: HTML parsing proceeds in the source code order. When a script i found, the parsing pauses until the script is done fetching and executing.
- Don't include the script in the head,some elements maynot already be added to the DOM tree
- `async`: Html parsing and script fetching occurs simultaneously(n in the background). But parsing stops and wait for the execution of the fetched script

- `defer`: The script is fetched asynhronously while Html is being parsed, and only starts executing after html parsing. This never interupts html parsing.

> Defer is the best approach. It guarantees that the scripts execute in he order specified in the source code. Unlike `async`

# Object Oriented Programming with JS

- In OOP;
- OOP is a programming paradigm based on the concept of objects
- Paradigm = style in which cod is organised and approached
- We use objects to _model_(describe) real world or abstract features. Eg Html component or data structures
- Objects may contain data(properties) and code(methods). By using objs we pack data and corresponding behavior into one block
- Objects are self-contained pieces/blocks of code
- Objects are building blocks of applications, and interact with one another
- Interactions happen through a public interface(API): methods that the code outside of the object can access and use to communicate witht the object
- OOP organizes code making it more flexible and easier to maintain (avoid spaghetti code)

### 1. Classes and instances (Traditional OOP)

- Class: a blueprint from which we can create new object
- Instance: a real object(with data), which is created from the class
- A clas can have several instances

### 2. The 4 fundamental OOP principles

- How do we a=design classes? How we model real-world data into classess

1. Abstraction

- Ignoring or hiding details that don't matter, allowing us to get an overview perspective of the thing we're implementing, instead of messing with details that don't matter to our implementaton

- Abstraction is everywhere in the programming world

2. Encapsulation

- Keeping properties and methods privtae inside the class, so they are not accessible from the outside the class. Some methods can be exposed as a public interface.
- Prevents external code from accidentally manipulating internal state
- _State of a class/object reffers to its data_
- Allows us ot chnage internal implementation without the risk of breaking external code

3. Inheritance

- Making all propertiesand methods of a certain class available to a child class, forming a hierarchical relationship between classes. This allows us to reuse common logic and to model real-world relationships

- A child classes inherits methods and properties form the parent class

4. Polymorphism

- A child class can overwrite a method it inherted from a parent class [it is momre complex than this]

## OOP in Javascript

- Objects are instantiated from a class, which functions like a blue print. This is the concept of classical OOP
- In Js, All objects are linked to a prototype. It is an object that contains methods and propertes that all it objects can access
- This is _Prototypal inheritance_: Objects are linked to a prototype object
- Behaviour is delegated to the liinked prototype object
- E.g. arrays methods are stored in Array.prototype. All arrays can use these memthods. n fact, they delegate this functionality to the prototype

### 3 Ways of implementing Prototypal inheritance in Js

- How do we create prototypes? How do we link objects to prototypes? How can we create new objects, without having classes?
- 1. Constructor functions

  - Technique to creat objects from a function
  - This is how built-in objects like Arrays, Maps, or Sets are actually implemented

- 2. ES6 classes

  - Modern alternative to constructor function syntax
  - Syntactc sugar: behind the scenes ES6 classes work like constructor functions
  - ES6 classes do not bahave like classes in classes in 'classial OOP'

- 3. Object.create()
  - The easiest and most straightforward way of linkng an object to a prototype

### Constructor functions and the `new` operator

- We call the constructor with the new operator
- Any function can be a constructro, except arrow fns b'se they dont have their own this keyword
- The `new` keyword/operator,

  1. A new obj is created
  2. The function is callled , the this keuword points to the obj
  3. The obj is linked to a prototype
  4. The function automatically returns an obj

```js
const Person = function (firstName, birthYear) {
  //instance properties
  this.firstName = firstName;
  this.birthYear = birthYear;

  this.calcAge = function () {
    return 2037 - this.birthYear;
  };
};

const jonas = new Person("Jonas", 1991);
jonas instanceof Person; //- true
```

> Donot add functions/methods inside a contructor function

### Prototypes - prototypal inheritance

- Each function in Js automatically has a property of `prototype`
- Every object created by a constructor functions gets acces the methods/properties of that constructor function

```js
console.log(Person.prototype);

Person.prototype.calcAge = function () {
  return 2037 - this.birthYear;
};

jonas.calcAge(); //works
```

- The prototype of the object is the same as the Function.prototype of the constructor function
- This is accessed via `.__proto__`

```js
jonas.__proto__ === Person.prototype; //- true
```

> `Person.prototype` is not the prototype of`Person`. It is the prototype of all objects created by that function

- Function.prototype === prototype of linked object
- `Obj.__proto__` or `Func.__proto__` === the prototype from which this particular object is made

- Setting properties on prototype

```js
Peson.prototype.species = "Homo sapiens";
jonas.species; //finds it
matilda.species; //finds it

// this is not an own property and is not stored directly on the object
jonas.hasOwnProperty("firstName"); //true
jonas.hasOwnProperty("species"); //false
```

> By convention constructor functions are capitalized

#### Prototypal inheritance / Delegation

- A constructor function has a prototype object which is the prototype of all instances
- The prototype has a reference back to this constructor (`Person.prototype.constructor`)

- The `new` operator

  - 1. An empty object is created
  - 2. `this` keyword in the constructor function call is set to the new object
  - 3. _The new object is linked (`__proto__` property) to the constructor function's prototype property_

    - The `__proto__` property always points to the objects prototype

  - 4. The new object is returned from the constructor functon call. Unless you explicitely return something else, which is prohibited

- This is how it works with the function constructors and ES6 classes, but not the `Object.create`

> If a function can not be found in the object itself, the JS engine searches for it in the prototype
> Then the object delegates this function's functionality to the prototype.
> This process of looking for methods and properties from prototypes is called "Prototype chain"

> The prototype chain goes on and on, from the object to it constructor.prototype, to the prototype of the constructor

###### Prototype Chain

```js
const arr = [1, 2, 3, 4];
arr.__proto__; //- prototype of my array object (Array.prototype)
arr.__proto__.__proto__; //- prototype of the Array() constructor function. Function is an object
arr.__proto__.__proto__.__proto__; //- -> null | prototype of the built in Array functon object is the top

//arr methods(built in methods)
Array.prototype.filter(); //and other methods

arr.__proto__ === Array.prototype;
arr.__proto__.__proto__ === Object.prototype;
arr.__proto__.__proto__.__proto__ === null;

//functions
const func = function () {};

func.__proto__ === Function.prototype;
func.__proto__ === Object.prototype;

Fuction.prototype.bind; // apply | call | etc
Object.prototype.hasOwnProperty | isPrototypeOf | toString | etc;
```

###### Prototypal inheritance on Built in objects

```js
jonas.__proto__; //- prototype of jonas
jonas.__proto__.__proto__; //- prototype of Person = OBJECT.PROTOTYPE
jonas.__proto__.__proto__.__proto__; //- null The Object.prototype is the top of the proto chain, no further

// constructor
Person.prototype.constructor; //- the function itself

//arrays
const arr = [1, 2, 3];
arr.__proto__; //- a prototype object that contains all array methods wc arrays inherit
arr.__proto__ === Array.prototype;

///adding new methods to all arrays
Array.prototype.unique = function () {
  return [...new Set(this)];
}[(1, 1, 1, 2, 3, 3)].unique(); //- [1, 2, 3]
```

> Extending the prototype of a built in objects is not good practice. The next Js version may have that propety and you overwrite it, it may also be confusing to debug with a large group of people

> THe protptypal inheritance is a mechanism for reusing code. Properties and methods have to exist only once in the engine, and can be used by many objects

```js
// experimenting with html elements
///a huge prototype chain

const h1 = document.querySelector("h1");
console.dir(h1); //- Js object representing the element

h1.__proto__ === HTMLHeadingElement;

h1.__proto__.__proto__ === HTMLElement; // === HTMLHeadingElement.__proto__

h1.__proto__.__proto__.__proto__ === Element;

h1.__proto__.__proto__.__proto__.__proto__ === Node;

h1.__proto__.__proto__.__proto__.__proto__.__proto__ === EventTarget;

h1.__proto__.__proto__.__proto__.__proto__.__proto__.__proto__ === Object;
```

```js
// experimenting with functions
const f = (x) => x + 1;

f.__proto__ = Function.prototype; //rpovides functions with methods and properties
```

### ES6 Classes

- Allow us to built the same thing as prototypes, but in a more modern syntactic approach
- The Es6 classes don't work like classical programming classes
- They are just syntatic sugar that abstrat the way we built objects using prototypes
- They implement prototypal inheritance behind the scenes
- Classes are like a specal type of functions

```js
e.g.
// class expression
const Person = class {}

// class declaation
class Person {
  //1. first thing, add constructor fn
  ///it's the function that is called when we call the class function with the new operator
  constructor(name, dob){
    this.firstName = name
    this.birthYear = dob
  }

  //outside the constructor, added to the prototype
  //methods
  calcAge(){
    return 2037 - this.birthYear
  }

  //no comma btn methods
  hello(){
    return `Hello ${this.firstName}`
  }


}

const jessica = new Person('Jes',1998)

jessica.__proto__ === Person.prototype

// normal prototypal inhertance works fine
Person.prototype.greet = function(){
  return `Hi ${this.firstName}`
}
```

> Properties and methods that added to the class outside the constructor function are added to the prototype

- _Note_
- 1. Classes are not hoisted: expressions and declarations
- 2. Classes are first-class citizens: we can return them from and pass them into functions. They are a special type of functions
- 3. Classes are executed in strict mode
- 4. Constructor functions are not deprecated, and can still be used if you're comfortable with them.
- 5. Classes should be used when we understand how Js prototypal inheritance works
- 6. Classes group code functionality that is related, into a single code block

### Setters and Getters

- Feature common to all Js object
- These are called "accessor properties", while the othes are called data properties
- They are functions that get and set a value
- To declare these prepend the method with "set" or "get"

```js
//ex;
const account = {
  owner = 'Jonas',
  movements: [200, 530, 120, 300],
  get latest(){
    return thiis.movements.slice(-1),pop()
  }

  set latest(mov){
    this.movements.push(mov)
  }

//setting a property that already exists
  set fullName(name){
    if(name.includes(' ')) this._fullName = name // using this.fullName that already exists causes an error: Max call stack size exceeded
    ///we create a new propertyname, to avoid the namin conflict
    ///for ths case, we should create a getter for it
    else console.log('Name is not a full name')
  }

  get fullName(){
    return this._fullName
  }

}

//usage - we use it as a property to get and set
account.latest //300
account.latest = 60


// ES6 classes
```

> we use them when we want to gte/set a certain property but after doing some calculations

> A setter method needs to have only one parameter
> It is not mandatory to write both a setter and getter for the same property. Either one works fine
> They work well with the ES6 class syntax
> These are very good for data validition

### Static methods

- A method attached to the constructor, not the the `prototype` property of the constructor
- E.g `Array.from` is used on the `Array` constructor but not accessible on all arrays

```js
//eg. Since functions are objects, add it to the function
Person.hey = function () {
  console.log("hey there");
  this; //- points to the constructor itself, because it is the object calling the method(RULE)
};

//ES6 classes - prepend with `static`
class Person {
  constructor() {}

  static hey() {
    this; //points to the whole class
  }
}
```

### `Object.create`

- No `new` operator and constructors.
- No prototype property invovled
- We use it to set the prototype of an object to anyother object

```js
//implementation
const PersonProto = {
  init(name, year) {
    //we manually define an initialisation
    this.fullName = name;
    this.birthYear = year;
  },
  calcAge() {
    return 2037 - this.birthYear;
  },
};

const steve = Object.create(PersonProto); //- object that is linked to PersonProto as its prototype
steve.name = "Steven";
steve.birthYear = 1997;
```

### Inheritance betweeen classes

- The more real and classical inheritance, (dfft from 'prototypal')
- One class inherits from another classes: Child - Parent inheritance

1. Using constructor functions

```js
const Person = function (firstName, birthYear) {
  this.firstName = firstName;
  this.birthYear = birthYear;
};

Person.prototyp.calcAge = function () {
  return 2037 - this.birthYear;
};

// const Student = function (firstName, birthYear, course) {
//   this.firstName = firstName;
//   this.birthYear = birthYear;
//   this.course = course
// };

// Student.prototype.introduce = function(){
//   return `Hi. I'm ${this.firstName}, doing ${ths.course}`
// }

//inheritance - call the Person function in the students object, with th `this` keyword set to the student/current object

const Student = function () {
  Person.call(this, firstName, birthYear);
  this.course = course;
};

// Linking prototyppes
/// set a link btn the two objects prototypes b4 adding any other properties
Student.prototype = Object.create(Person.prototype);
Student.prototype.introduce = function () {
  return `Hi. I'm ${this.firstName}, doing ${ths.course}`;
};

Student.prototype.constructor; //--> Person instead of Student b'se we used Object.create
Student.prototype.constructor = Student; //we need to set it manually

const mike = new Student("Michael", 2001, "CompSci");
mike.calcAge(); //- works fine
mike.introduce(); //- works

//analyse
mike.__proto__; //Person.prototype = Person object
mike.__proto__._proto__; //Person.__proto__
```

2. Using ES6 classes

```js
class Person {
  constructor(name, dob) {
    this.firstName = name;
    this.birthYear = dob;
  }
  calcAge() {
    return 2037 - this.birthYear;
  }

  hello() {
    return `Hello ${this.firstName}`;
  }
}

// we use `extends` and the linking of prototypes is doen automatically behind the scenes
///we need the `extends` and `super` keywords

class Students extends Person {
  constructor(fullName, birthYear, course) {
    super(fullName, birthYear); //call the parent class constructor with `this` set to this child class
    this.course = course;
  }
}

// if we dont need any extra properties in the child class, we don't need to call the constructor
class Students extends Person {}
```

3. Using `Object.create`

```js
const PersonProto = {
  init(name, year) {
    this.fullName = name;
    this.birthYear = year;
  },
  calcAge() {
    return 2037 - this.birthYear;
  },
};

const steve = Object.create("Steven", 2000);

const StudentProto = Object.create(PersonProto);

StudentProto.init = function (firstName, birthYear, course) {
  PersonProto.init.call(this, firstName, birthYear);
  this.course = course;
};

const jay = Object.create(StudentProto);
jay.init("Jay", 2003, "CompSci");
```

#### Another class example

```js
class Account {
  constructor(owner, currency, pin) {
    this.owner = owner;
    this.currency = currency;
    this.pin = pin;
    this.movements = [];
    this.locale = navigator.language;
  }

  //public interface
  getMovements() {
    return this.movements;
  }

  withdraw(val) {
    this.movements.push(-val);
  }

  deposit(val) {
    this.movements.push(val);
  }
}
```

#### Encapsulation: Protected properties and methods

- To keep some methods and properties of a class/object private to the class so that they are not accessible from outside.
- The rest are accessible via a public interface
- 1. Prepend an underscore (\_). A convention, and users will know thta they shouldn't access it.
- SO they are not private, they are only protected

```js
class Account {
  constructor(owner, currency, pin) {
    this.owner = owner;
    this.currency = currency;
    this._pin = pin;
    this._movements = [];
    this.locale = navigator.language;
  }

  //public interface
  getMovements() {
    return this._movements;
  }

  _appoveLoan() {
    //protected methhod
  }

  withdraw(val) {
    this.movements.push(-val);
  }

  deposit(val) {
    this.movements.push(val);
  }
}
```

- True pivate and protected properties
- These are called class fields:
- Js classes are moving away from being just syntatic sugar and becoming more classical

- There are public fields and methods and private fields and methods
- There are available in the instances

```js
class Account {
  //1. public fields - like a var, now const/let, end with a semi colon, referenceable via the this keyword
  locale = navigator.language;

  //2. private fields - prepend a '#'
  #movements = [];
  #pin;

  constructor(owner, currency, pin) {
    this.owner = owner;
    this.currency = currency;

    this.#pin = pin;
  }

  //3. public methods
  getMovements() {
    return this.#movements;
  }

  withdraw(val) {
    this.#movements.push(-val);
  }

  deposit(val) {
    this.#movements.push(val);
  }

  //4. private methods - prepend it with a '#'
  #approveLoan(val) {}
}
```

> Static methods: Methods on avaibl on the class itself, not the instances
> There are static versions for each of the private and public fields and methods

```js
// prepend the `static` keyword on the declaration
```

> _To enable chainig of methods_, every method should `return` the `this` keyword i.e the invoking object

# MAPTY PROJECT: OOP, Geolocation, External libraries, local storage

## Project planning

1. User storie

- Decription of the appliction' functionality from the uer' perpective. All user storie put together decribe the entire application

2. Features

- Developer know which features are needed in the app
- Obtained based on user stories

3. Flow chart

- What we will build

4. Architecture

- HOW we will built it
- We dont need to have a perfect piture of the architecture of the app, we can start deveoping and improve the architecture with time

5. Development step

## Geolocation API

- It is one of the Web APIs provided by the browser

```js
if (!navigator.geolocation) return; //guard clause
navigator.geolocation.getCurrentPosition(); //1st arg = success callback 2nd arg error callback

navgator.geolocation.getCurrentPosition(
  function (position) {
    position; //object of current position
    const { latitude, longitude } = position.coords; //get the coords
    console.log(`https://www.googlept/maps/@${latitude},${longitude}`);
  },
  function () {
    alert("Couldn't get your location");
  }
);
```

## Displaying maps using leaflet.js

- First include it as a CDN links,
- Requires css files and Js files
- Can be usedas an npm package
- (leafletjs.com/index.html)
